<!DOCTYPE html>
<meta charset="utf-8">
<html>
  <head>
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <script type="text/javascript" src="./js/eventOffsetLineChart.js"></script>
    <script type="text/javascript" src="./js/readFiles.js"></script>

    <style>
      body{
        font: 12px sans-serif;
        margin: 4px 20px 0px 20px;
        background: whitesmoke;
      }
    </style>
  </head>
  <body>
    <!-- <center> -->
      <h2>VitalVis: Event Effects Visualization Prototype</h2>
      <!-- <p>
        <b>Description:</b> Correlation matrix visualization with scatterplot.
      </p> -->
    
      <h3>Instructions:</h3>
      <p>
        <b>Loading Files:</b> Either select files in your system file explorer and drag and drop on the 'Choose Files' button or click the 'Choose Files' button and select files from the system file dialog. Multiple files can be loaded.</br>
      </p>

      <h3>Controls:</h3>
      <p>
        <label for="fileInput">Files: </label>
        <input type="file" id="fileInput" onchange="loadFiles()" multiple><br/><br/>

        <label for="eventGroupSelect">Event Group: </label>
        <select id="eventGroupSelect" onChange="eventGroupSelected()"></select><br/><br/>

        <label for="eventNameSelect">Event Name:</label>
        <select id="eventNameSelect" onChange="eventNameSelected()"></select><br/><br/>

        <label for="sortSelect">Sort By:</label>
        <select id="sortSelect" onChange="sortSelectChanged()">
          <option >Name</option>
          <option selected>Dosages Sampled</option>
          <!-- <option>Variation</option> -->
        </select><br/><br/>

        <!-- <label for="binSizeRange">Bin Size (in minutes): </label><input type="range" min="1" max="15" value="1" class="slider" id="binSizeRange" onchange="binSizeRangeChanged()">
        <span id="binSizeRangeText">1</span><br/><br/>
        <label for="opacityRange">Scatterplot Point Opacity: </label><input type="range" min="1" max="100" value="35" class="slider" id="opacityRange" onchange="opacityRangeChanged()">
        <span id="opacityRangeText">35</span><br/><br/>
        <input type="checkbox" id="ageCheck" onchange="ageCheckChanged()"><label for="ageCheck"> Extract Age Dimension?</label><br/><br/> -->
        <!-- <input type="checkbox" id="showUnselectedCheck" onchange="showUnselectedCheckChanged()"><label for="ageCheck"> Show Unselected Lines?</label><br/> -->
        
      </p>
    <!-- </center> -->
    <hr/>
    <h3>Charts:</h3>
    <div id="charts"></div>
    <br/>
    <br/>
    <!-- <hr/> -->

    <script>
      const margin = {top: 20, right: 20, bottom: 30, left: 60};
      let chartData;
      let summaryData;
      let nearEventVitals;
      let chart;
      const timeWindowMinutes = 10;

      /*
      const filenames = ['10060.json', '10095.json', '101213.json', '101466.json', '10153.json', '100629.json', '101123.json', '101242.json', '101484.json', '102403.json', '100661.json', '101189.json', '101365.json', '1015.json', '10275.json', '10069.json', '101207.json', '10145.json', '101521.json'];

      for (i in filenames) { filenames[i] = 'data/' + filenames[i]; };

      
      readFilesFromNames(filenames, (fileData) => {
        chartData = fileData;
        console.log(chartData);

        // for each fluid, get values in window of time around fluid time
        if (chartData) {
          extractData();
          populateFluidGroupSelectOptions(); 
        }
      });
      */
      const eventSummaryFiles = ["data/fluidsSummary.json", "data/drugsSummary.json"];
      Promise.all(eventSummaryFiles.map(f => d3.json(f)))
        .then(filesData => {
          console.log(filesData);
          summaryData = {};
          filesData.forEach(data => {
            d3.keys(data).forEach(key => {
              summaryData[key] = data[key];
            });
          });
          // summaryData = d3.merge(filesData[0], filesData[1]);
          console.log(summaryData);
          // summaryData = filesData[0].concat(filesData[1]);
          populateEventGroupSelectOptions();
        })
        .catch(error => {
          console.log(error);
        });
      // d3.json(fluidsSummaryFile)
      //   .then((data) => {
      //     console.log(data);
      //     summaryData = data;
      //     populateEventGroupSelectOptions();
      //   })
      //   .catch((error) => {
      //     console.log(error);
      //   });

      const populateEventGroupSelectOptions = () => {
        const groupSelect = document.getElementById('eventGroupSelect');
        for (i in groupSelect.options) { 
          groupSelect.remove(i); 
        }

        let eventGroups = d3.keys(summaryData);
        eventGroups.sort(d3.ascending);
        groupSelect.options[0] = new Option('Select Group', 0);
        groupSelect.value = 0;
        eventGroups.forEach(eventGroup => {
          groupSelect.options[groupSelect.options.length] = new Option(eventGroup);
        });
        eventGroupSelected();
        
        // let eventGroups = [...new Set(nearEventVitals.map(d => d.egroup))];
        // // let fluidGroups = [...fluidGroupSet];

        // eventGroups.sort(d3.ascending);
        // groupSelect.options[0] = new Option('Select Group', 0);
        // groupSelect.value = 0;
        // eventGroups.forEach(eventGroup => {
        //   groupSelect.options[groupSelect.options.length] = new Option(eventGroup);
        // });
        // eventGroupSelected();
      }

      const eventGroupSelected = () => {
        const groupSelect = document.getElementById('eventGroupSelect');
        const nameSelect = document.getElementById('eventNameSelect');

        const selectedGroup = groupSelect.options[groupSelect.selectedIndex].text;

        for (i in nameSelect.options) {
          nameSelect.remove(i);
        }

        nameSelect.options[0] = new Option('Select Name', 0);
        nameSelect.value = 0;

        if (selectedGroup != 'Select Group') {
          let eventNames = d3.keys(summaryData[selectedGroup]);
          // let eventNames = [...new Set(nearEventVitals.filter(d => d.egroup === selectedGroup).map(d => d.ename))];
          eventNames.sort(d3.ascending);
          eventNames.forEach(eventName => {
            nameSelect.options[nameSelect.options.length] = new Option(eventName);
          });
        }
        removeCharts();
      }

      const eventNameSelected = () => {
        removeCharts();
        createCharts();
      }

      const sortSelectChanged = () => {
        removeCharts();
        createCharts();
      }

      const removeCharts = () => {
        delete chartData;
        delete nearEventVitals;
        d3.select('#charts').selectAll("*").remove();
      }

      // const binSizeRangeChanged = () => {
      //   const binSize = document.getElementById('binSizeRange').value;
      //   const binSizeRangeText = document.getElementById('binSizeRangeText');
      //   binSizeRangeText.innerText = new String(binSize);
      //   removeChart();
      //   createChart();
      // }

      const loadFiles = () => {
        const files = document.getElementById('fileInput').files;
        if (files) {
          // console.log(files);
          readFiles(files, (fileData) => {
            chartData = fileData;
            if (chartData) {
              console.log(chartData);
              extractData();
              summaryData = makeSummaryInfo(nearEventVitals);
              populateEventGroupSelectOptions(); 
            }
            // removeChart();
            // createChart();
          })
        }
      };

      const extractData = () => {
        // for each fluid, get values in window of time around fluid time
        if (chartData) {
          nearEventVitals = [];
          chartData.forEach(chartDatum => {
            chartDatum.fluids.forEach(fluidNode => {
              const timeExtent = [d3.timeMinute.offset(fluidNode.time, -timeWindowMinutes), d3.timeMinute.offset(fluidNode.time, timeWindowMinutes)];

              // cycle through the vitals and capture values in time extent range
              chartDatum.vitals.forEach(vitalNode => {
                let nearValues = vitalNode.values.filter(v => (v.time >= timeExtent[0] && v.time <= timeExtent[1]));
                if (nearValues.length > 0) {
                  // calculate elapsed time since event
                  nearValues.map( v => {
                    v.minutesSinceEvent = d3.timeMinute.count(fluidNode.time, v.time)
                  });
                  
                  let nearEventVitalsEvent = nearEventVitals.find(d => (d.egroup === fluidNode.group && d.ename === fluidNode.name));
                  if (!nearEventVitalsEvent) {
                    nearEventVitalsEvent = {
                      egroup: fluidNode.group,
                      ename: fluidNode.name,
                      vitals: [],
                    };
                    nearEventVitals.push(nearEventVitalsEvent);
                  }

                  let nearEventVitalsVital = nearEventVitalsEvent.vitals.find(d => (d.vgroup === vitalNode.group && d.vname === vitalNode.name));
                  if (!nearEventVitalsVital) {
                    nearEventVitalsVital = {
                      vgroup: vitalNode.group,
                      vname: vitalNode.name,
                      values: [],
                      numDosagesSampled: 0,
                    };
                    nearEventVitalsEvent.vitals.push(nearEventVitalsVital);
                  }
                  nearEventVitalsVital.values = nearEventVitalsVital.values.concat(nearValues);
                  nearEventVitalsVital.numDosagesSampled = nearEventVitalsVital.numDosagesSampled + 1;
                }
              });
            });
            chartDatum.drugs.forEach(drugNode => {
              const timeExtent = [d3.timeMinute.offset(drugNode.time, -timeWindowMinutes), d3.timeMinute.offset(drugNode.time, timeWindowMinutes)];

              // cycle through the vitals and capture values in time extent range
              chartDatum.vitals.forEach(vitalNode => {
                let nearValues = vitalNode.values.filter(v => (v.time >= timeExtent[0] && v.time <= timeExtent[1]));
                if (nearValues.length > 0) {
                  // calculate elapsed time since event
                  nearValues.map( v => {
                    v.minutesSinceEvent = d3.timeMinute.count(drugNode.time, v.time)
                  });
                  
                  let nearEventVitalsEvent = nearEventVitals.find(d => (d.egroup === drugNode.group && d.ename === drugNode.name));
                  if (!nearEventVitalsEvent) {
                    nearEventVitalsEvent = {
                      egroup: drugNode.group,
                      ename: drugNode.name,
                      vitals: [],
                    };
                    nearEventVitals.push(nearEventVitalsEvent);
                  }

                  let nearEventVitalsVital = nearEventVitalsEvent.vitals.find(d => (d.vgroup === vitalNode.group && d.vname === vitalNode.name));
                  if (!nearEventVitalsVital) {
                    nearEventVitalsVital = {
                      vgroup: vitalNode.group,
                      vname: vitalNode.name,
                      values: [],
                      numDosagesSampled: 0,
                    };
                    nearEventVitalsEvent.vitals.push(nearEventVitalsVital);
                  }
                  nearEventVitalsVital.values = nearEventVitalsVital.values.concat(nearValues);
                  nearEventVitalsVital.numDosagesSampled = nearEventVitalsVital.numDosagesSampled + 1;
                }
              });
            });
          });
          // console.log(nearEventVitals);         

          // construct bins for fluid / vital near values
          // nearEventVitals.forEach(fnode => {
          //   fnode.vitals.forEach(vnode => {
          //     vnode.bins = d3.histogram()
          //       .value(d => d.minutesSinceEvent)
          //       .domain([-timeWindowMinutes, timeWindowMinutes])
          //       .thresholds((timeWindowMinutes * 2) + 1)
          //       (vnode.values);

          //     // calculate summary info for bins
              
          //     vnode.bins.forEach(bin => {
          //       bin.mean = d3.mean(bin, d => d.value);
          //       bin.stdev = d3.deviation(bin, d => d.value);
          //     });
          //   });
          // });
        }
      };

      const makeSummaryInfo = (eventVitals) => {
        let binnedEventVitals = {};

        eventVitals.forEach(eventNode => {
          let eventGroup = binnedEventVitals[eventNode.egroup];
          if (!eventGroup) {
            eventGroup = {};
            binnedEventVitals[eventNode.egroup] = eventGroup;
          }
          
          let eventName = eventGroup[eventNode.ename];
          if (!eventName) {
            eventName = {};
            eventGroup[eventNode.ename] = eventName;
          }

          eventNode.vitals.forEach(vitalNode => {
            let vitalGroup = eventName[vitalNode.vgroup];
            if (!vitalGroup) {
              vitalGroup = {};
              eventName[vitalNode.vgroup] = vitalGroup;
            }

            let vitalName = vitalGroup[vitalNode.vname];
            if (!vitalName) {
              vitalName = [];
              vitalGroup[vitalNode.vname] = vitalName;
            }

            let valueBins = d3.histogram()
              .value(d => d.minutesSinceEvent)
              .domain([-timeWindowMinutes, timeWindowMinutes])
              .thresholds((timeWindowMinutes * 2) + 1)
              (vitalNode.values);
            
            valueBins.forEach(bin => {
              let sortedValues = bin.map(d => d.value).sort(d3.ascending);
              vitalName.push({
                minutesSinceEvent: (bin.x0 + bin.x1) / 2.,
                mean: d3.mean(sortedValues),
                stdev: d3.deviation(sortedValues),
                median: d3.median(sortedValues),
                q1: d3.quantile(sortedValues, 0.25),
                q3: d3.quantile(sortedValues, 0.75),
                min: sortedValues[0],
                max: sortedValues[sortedValues.length - 1],
                n: sortedValues.length,
                dosagesSampled: vitalNode.numDosagesSampled,
              });
            });
          });
        });

        return binnedEventVitals;
      }

      const createCharts = () => {
        if (summaryData) {
          const groupSelect = document.getElementById('eventGroupSelect');
          const nameSelect = document.getElementById('eventNameSelect');
          const sortSelect = document.getElementById('sortSelect');
          const selectedEventGroup = groupSelect.options[groupSelect.selectedIndex].text;
          const selectedEventName = nameSelect.options[nameSelect.selectedIndex].text;
          const selectedSortOption = sortSelect.options[sortSelect.selectedIndex].text;
          
          let chartWidth = document.getElementById('charts').clientWidth;
          let chartHeight = 200;
          
          let vitalPlotData = [];
          const vitalGroups = d3.keys(summaryData[selectedEventGroup][selectedEventName]);
          vitalGroups.forEach(vitalGroup => {
            const vitalNames = d3.keys(summaryData[selectedEventGroup][selectedEventName][vitalGroup]);
            vitalNames.forEach(vitalName => {
              // console.log(`${vitalGroup} : ${vitalName}`);
              let plotData = summaryData[selectedEventGroup][selectedEventName][vitalGroup][vitalName].map(d => {
                const iqr = d.q3 - d.q1;
                return {
                  minutesSinceEvent: d.minutesSinceEvent,
                  typical: d.median,
                  innerRangeMin: d.q1,
                  innerRangeMax: d.q3,
                  outerRangeMin: Math.max(d.min, d.q1 - iqr * 1.5),
                  outerRangeMax: Math.min(d.max, d.q3 + iqr * 1.5),
                  // rangeMin: d.mean - d.stdev,
                  // rangeMax: d.mean + d.stdev,
                  dosagesSampled: d.dosagesSampled,
                }
              });
              // console.log(plotData);
              // filter out undefined values
              plotData = plotData.filter(d => !isNaN(d.typical) && !isNaN(d.innerRangeMax) && !isNaN(d.innerRangeMin));

              let zeroData = plotData.filter(d => d.typical === 0);

              if (plotData.length > 1 && (zeroData.length != plotData.length)) {
                vitalPlotData.push({
                  title: `${vitalGroup} : ${vitalName}  (Dosaged Sampled: ${plotData[0].dosagesSampled})`,
                  dosagesSampled: plotData[0].dosagesSampled,
                  data: plotData,
                });
              }
              // if (plotData.length > 1 && (zeroData.length != plotData.length)) {
              //   let timeExtent = [-10, 10];
              //   let chart = eventOffsetLineChart()
              //     .titleText(`${vitalGroup}  |  ${vitalName}  (Dosages Sampled: ${plotData[0].dosagesSampled})`)
              //     .margin(margin)
              //     .dateExtent(timeExtent)
              //     .width(chartWidth)
              //     .height(chartHeight)
              //     .zoomWithWheel(false)
              //     .showPoints(true)
              //     .showLine(true)
              //     // .curveFunction(d3.curveStepAfter)
              //     .dateValue((d) => d.minutesSinceEvent)
              //     .yValue((d) => d.typical)
              //     .lowValue(d => d.innerRangeMin)
              //     .highValue(d => d.innerRangeMax);
              //   d3.select('#charts').call(chart, plotData);
              // }
            });
          });

          vitalPlotData.sort((a, b) => {
            if (selectedSortOption === 'Name') {
              if (a.title > b.title) {
                return 1;
              } else if (a.title < b.title) {
                return -1;
              } else {
                return 0;
              }
            } else if (selectedSortOption === 'Dosages Sampled') {
              return b.dosagesSampled - a.dosagesSampled;
            }
          });

          const timeExtent = [-10, 10];
          vitalPlotData.forEach(plotData => {
            const chart = eventOffsetLineChart()
              .titleText(plotData.title)
              .margin(margin)
              .dateExtent(timeExtent)
              .width(chartWidth)
              .height(chartHeight)
              .zoomWithWheel(false)
              .showPoints(true)
              .showLine(true)
              // .curveFunction(d3.curveStepAfter)
              .dateValue((d) => d.minutesSinceEvent)
              .yValue((d) => d.typical)
              .lowValue(d => d.innerRangeMin)
              .highValue(d => d.innerRangeMax);
            d3.select('#charts').call(chart, plotData.data);
          });
        }

        /*
        if (nearEventVitals) {
          console.log(nearEventVitals);
          const groupSelect = document.getElementById('eventGroupSelect');
          const nameSelect = document.getElementById('eventNameSelect');
          const selectedEventGroup = groupSelect.options[groupSelect.selectedIndex].text;
          const selectedEventName = nameSelect.options[nameSelect.selectedIndex].text;
          
          let chartWidth = document.getElementById('charts').clientWidth;
          let chartHeight = 200;
          
          nearEventVitals.forEach(eventRecord => {
            if (eventRecord.egroup === selectedEventGroup && 
              eventRecord.ename === selectedEventName) {
                eventRecord.vitals.forEach(vitalRecord => {

                  let plotData = vitalRecord.bins.map(d => {
                    return {
                      minutesSinceEvent: d.x0,
                      mean: d.mean,
                      innerRangeMin: d.mean - d.stdev,
                      innerRangeMax: d.mean + d.stdev,
                    }
                  });

                  // filter out undefined values
                  plotData = plotData.filter(d => !isNaN(d.mean) && !isNaN(d.innerRangeMax) && !isNaN(d.innerRangeMin));

                  let zeroData = plotData.filter(d => d.mean === 0);
                  // console.log(vitalRecord);
                  // console.log(plotData);

                  if (plotData.length > 1 && (zeroData.length != plotData.length)) {
                    let timeExtent = [-10, 10];
                    let chart = eventOffsetLineChart()
                      .titleText(`${vitalRecord.vgroup}  |  ${vitalRecord.vname}  (Dosages Sampled: ${vitalRecord.numDosagesSampled})`)
                      .margin(margin)
                      .dateExtent(timeExtent)
                      .width(chartWidth)
                      .height(chartHeight)
                      .zoomWithWheel(false)
                      .showPoints(true)
                      .showLine(true)
                      // .curveFunction(d3.curveStepAfter)
                      .dateValue((d) => d.minutesSinceEvent)
                      .yValue((d) => d.mean)
                      .lowValue(d => d.innerRangeMin)
                      .highValue(d => d.innerRangeMax);
                    d3.select('#charts').call(chart, plotData);
                  }
              });
            }
          });
        }
        */
      };
    </script>
  </body>
</html>